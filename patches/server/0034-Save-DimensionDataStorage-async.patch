From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cryptite <cryptite@gmail.com>
Date: Mon, 26 Jun 2023 16:45:00 -0500
Subject: [PATCH] Save DimensionDataStorage async


diff --git a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
index 637a86e74d633901fdd2f2f1ba6aa4ed49780ead..8cf3880d9168b5ba6b383ec921bfb490ea51ac38 100644
--- a/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
+++ b/src/main/java/net/minecraft/world/level/storage/DimensionDataStorage.java
@@ -9,6 +9,8 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.PushbackInputStream;
 import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -18,11 +20,12 @@ import net.minecraft.nbt.NbtIo;
 import net.minecraft.nbt.NbtUtils;
 import net.minecraft.util.datafix.DataFixTypes;
 import net.minecraft.world.level.saveddata.SavedData;
+import org.bukkit.Bukkit;
 import org.slf4j.Logger;
 
 public class DimensionDataStorage {
     private static final Logger LOGGER = LogUtils.getLogger();
-    public final Map<String, SavedData> cache = Maps.newHashMap();
+    public final Map<String, SavedData> cache = new ConcurrentHashMap<>();
     private final DataFixer fixerUpper;
     private final File dataFolder;
 
@@ -51,7 +54,7 @@ public class DimensionDataStorage {
         SavedData savedData = this.cache.get(id);
         if (savedData == null && !this.cache.containsKey(id)) {
             savedData = this.readSavedData(readFunction, id);
-            this.cache.put(id, savedData);
+            if (savedData != null) this.cache.put(id, savedData);
         }
 
         return (T)savedData;
@@ -119,11 +122,12 @@ public class DimensionDataStorage {
     }
 
     public void save() {
-        this.cache.forEach((id, state) -> {
+        // Slice start - run async
+        CompletableFuture.runAsync(() -> this.cache.forEach((id, state) -> {
             if (state != null) {
                 state.save(this.getDataFile(id));
             }
-
-        });
+        }));
+        // Slice end
     }
 }
